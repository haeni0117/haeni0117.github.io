#깨지고 부서져라님 코드참조
#1012유기농배추 : 솔루션 코드 공부하기
#입력값 t받기
t = int(input())#총 몇 개의 케이스인지 -> 입력라인 말하는 거 아님
# 우 좌 하 상 => 방향
dx = [1, -1, 0, 0]
dy = [0, 0, -1, 1]


#bfs탐색함수 선언
def bfs(x, y):
    #깊이 우선 탐색으로 조사를 시작한다
    queue = [[x, y]]
    #queue에는 좌표데이터가 들어가고 자료형태는 리스트? 
    #2차원배열의 또다른 형태인듯? [x][y]=[[x,y]]인지 확인해야겠군 nono
    #x = [0][0]이고, y=[0][1]
    while queue:
        #인근 밭에 연결될 수 있는지를 확인하면, 그 밭에서는 또 연결될 수 있나를 찾아본다.
        #연결된다면 이 17th 라인은 끝나겠지만, 계속 연결되는 한 끝나지 않을 것임
        a, b = queue[0][0], queue[0][1]
        #x와 y값을 각각 변수 a,b에 할당시켜준다. 굳이? 싶기는 하지만 뭐 일단 ㅇㅋ
        #-> 왜 굳이?라고 생각했냐면 그냥 x,y그대로 써주는 건 안되냐는 의문이 생겨서이다.
        del queue[0]
        #x,y값을 a,b변수에 저장한 후 지워버린다. 
        for i in range(4):
            #4가지 case에 대해 ; 4인 이유는 방향이 4가지라서(위,아래,좌,우)
            q = a + dx[i]
            w = b + dy[i]
            #각각의 케이스에 대해 이동가능성을 조사하기 위한 setting 
            #굳이 모든 케이스에 대해 조사하는 것은 무의미 + 비효율적이므로 후보case설정하는 것
            if 0 <= q < n and 0 <= w < m and s[q][w] == 1:
                #앞에서 찾아준 후보case에 대해 
                #1. 밭이 존재하는지 
                #2. 밭이 존재하는지 여부를 따져보기 이전에 이동할 수 있는지(마지막 블록이면 더 이상 이동할 수 없음)=> arrayerror 막기 위해서
                s[q][w] = 0
                #조사해준 인근 밭 제외하기 위해서 1->0으로 바꿔준다
                queue.append([q, w])
                #만약 밭도 존재하고 범위도 오버하지 않으면 큐 리스트에 저장해준다.
                #아까 queue에서 del한 이유는 음....
                #[0][0]깔끔하게 조사하려고 + queue리스트에 자기자신을 제외한 밭들만 넣으려고(얼마나 연결될 수 있나 조사)


for i in range(t):
    #모든 케이스개수(t)에 대해서 조사한다.
    m, n, k = map(int, input().split()) #m과 n과 k값을 map으로 받아온다.
    s = [[0] * m for i in range(n)]
    #입력받은 가로(m)과 세로(n)을 적용시켜준다
    cnt = 0
    #배추지렁이 마리수ㅇ
    #아직 필요한 배추지렁이(?) 없음 -> "아파트단지"같은 존재
    for j in range(k):#t로 나타나는 케이스 내부에서 입력받는 케이스들을 입력받기(+저장하기)
        a, b = map(int, input().split())
        #a와 b는 각각 가로축과 세로축에서의 위치값을 의미함
        s[b][a] = 1 
        #배추밭이 존재한다! -> 배열의 값을 1로 설정
        #모든 공간에 대해 배추밭이 있는지 없는지 조사를 완료함(0 or 1)!                                                                                                                                                                                 
    for q in range(n):
        for w in range(m):
            #가로(n)과 세로(m)에 대해 조사한다
            if s[q][w] == 1:
                #고로 q와 w는 밭의 위치에 대한 <<좌표>>이다.
                #만약 해당배열의 값이 1이라면 = 밭이 존재한다면?
                #여기서 시작 -> 조사를 시작할 밭을 설정했다(1st 조사에서만!)
                bfs(q, w)
                #탐색을 시작할 밭을 정하고 dfs방식으로 탐색을 시작한다. 
                s[q][w] = 0
                cnt += 1
    print(cnt)
    #몇 마리의 배추흰지렁이가 필요한지 조사한다